<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Baymax AR Filter</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- MediaPipe Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    
    <style>
        body {
            background-color: #1a1a1a;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            margin: 0;
        }
        
        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
        }

        canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Mirror effect */
        }

        #input-video { display: none; }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
            transition: opacity 0.5s;
        }

        /* Classic Baymax Loader */
        .baymax-loader {
            width: 100px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
        }

        .eye {
            width: 15px;
            height: 15px;
            background: white;
            border-radius: 50%;
            animation: blink 3s infinite;
        }

        .line {
            height: 4px;
            flex-grow: 1;
            background: white;
            margin: 0 5px;
        }

        @keyframes blink {
            0%, 90%, 100% { transform: scaleY(1); }
            95% { transform: scaleY(0.1); }
        }

        .controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 40;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            width: 100%;
            pointer-events: none;
        }
        
        .hint-text {
            background: rgba(0,0,0,0.6);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            color: #fff;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255,255,255,0.1);
            text-align: center;
        }

        .btn {
            pointer-events: auto;
            background: white;
            color: black;
            padding: 10px 24px;
            border-radius: 99px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .btn:active { transform: scale(0.95); }

        /* Flash */
        @keyframes flash {
            0% { opacity: 0.8; background: white; }
            100% { opacity: 0; background: transparent; }
        }
        .flash-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 60;
        }
        .flash-active { animation: flash 0.5s ease-out forwards; }

        #countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 120px;
            font-weight: 900;
            color: white;
            text-shadow: 0 0 20px rgba(0,0,0,0.5);
            z-index: 55;
            display: none;
        }
    </style>
</head>
<body>

    <div id="loading" class="loading-overlay">
        <div class="baymax-loader">
            <div class="eye"></div>
            <div class="line"></div>
            <div class="eye"></div>
        </div>
        <p class="mt-4 text-gray-300 font-light text-center">Initializing Healthcare Companion...</p>
    </div>

    <div id="flash-overlay" class="flash-overlay"></div>
    <div id="countdown">3</div>

    <div id="canvas-container">
        <video id="input-video" playsinline></video>
        <canvas id="output-canvas"></canvas>
        
        <div class="controls">
            <div id="status-msg" class="hint-text">Show a ✊ (Fist) to take a screenshot!</div>
            <button onclick="toggleFilter()" class="btn">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M10.5 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0z"/>
                    <path d="M0 8s3-5.5 8-5.5S16 8 16 8s-3 5.5-8 5.5S0 8 0 8zm8 3.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7z"/>
                </svg>
                Toggle Suit
            </button>
        </div>
    </div>

    <script>
        const videoElement = document.getElementById('input-video');
        const canvasElement = document.getElementById('output-canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const loadingScreen = document.getElementById('loading');
        const flashOverlay = document.getElementById('flash-overlay');
        const countdownEl = document.getElementById('countdown');
        const statusMsg = document.getElementById('status-msg');
        
        // --- State Management ---
        let isFilterActive = true;
        let isFaceLoaded = false;
        let isHandLoaded = false;
        let isPoseLoaded = false;
        
        let latestFaces = null;
        let latestHands = null;
        let latestPose = null;
        
        let fistDetectedFrames = 0;
        let isCountingDown = false;
        const FIST_TRIGGER_FRAMES = 15;

        // Failsafe: Remove loader after 10s
        setTimeout(() => {
            if (loadingScreen.style.display !== 'none') {
                loadingScreen.style.display = 'none';
            }
        }, 10000);

        function resizeCanvas() {
            canvasElement.width = window.innerWidth;
            canvasElement.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function toggleFilter() { isFilterActive = !isFilterActive; }

        function checkLoadStatus() {
            if (isFaceLoaded && isHandLoaded && isPoseLoaded) {
                loadingScreen.style.opacity = '0';
                setTimeout(() => loadingScreen.style.display = 'none', 500);
            }
        }

        // --- Render Loop ---
        function renderLoop() {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            // 1. Draw Real Video Background (No Cyberpunk Overlay)
            canvasCtx.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);

            if (isFilterActive) {
                // 2. Draw Body (Uses Logic from React Snippet)
                if (latestPose && latestPose.poseLandmarks && latestPose.poseLandmarks.length > 0) {
                    drawBaymaxBody(latestPose.poseLandmarks);
                }

                // 3. Draw Faces
                if (latestFaces && latestFaces.multiFaceLandmarks) {
                    latestFaces.multiFaceLandmarks.forEach((lm, i) => drawHeroMask(lm, i));
                }

                // 4. Hands
                if (latestHands && latestHands.multiHandLandmarks) {
                    latestHands.multiHandLandmarks.forEach(lm => checkHandGesture(lm));
                }
            }
            
            canvasCtx.restore();
            requestAnimationFrame(renderLoop);
        }

        // --- Helper: Rounded Rect ---
        function drawRoundedRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

        const HERO_THEMES = [
            { mainColor: '#FFFFFF', highlight: '#FFFFFF', shadow: '#D0D0D0', visorColor: null, eyeColor: '#111111', style: 'classic' },
            { mainColor: '#FF3333', highlight: '#FF6666', shadow: '#990000', visorColor: '#330066', eyeColor: '#00FFFF', style: 'visor' }, 
            { mainColor: '#FFEE00', highlight: '#FFFF99', shadow: '#CCAA00', visorColor: '#222222', eyeColor: '#FFFFFF', style: 'visor' }, 
            { mainColor: '#00FF66', highlight: '#66FF99', shadow: '#009933', visorColor: '#003322', eyeColor: '#AAFFEE', style: 'visor' }
        ];

        // --- BODY LOGIC (From React Snippet) ---
        function drawBaymaxBody(landmarks) {
            const getPt = (idx) => ({ x: landmarks[idx].x * canvasElement.width, y: landmarks[idx].y * canvasElement.height });
            const getVis = (idx) => landmarks[idx].visibility !== undefined ? landmarks[idx].visibility : 1.0;

            if (getVis(11) < 0.5 || getVis(12) < 0.5) return;

            const lShoulder = getPt(11), rShoulder = getPt(12);
            const lElbow = getPt(13), rElbow = getPt(14);
            const lWrist = getPt(15), rWrist = getPt(16);
            const lHip = getPt(23), rHip = getPt(24);
            const lKnee = getPt(25), rKnee = getPt(26);
            const lAnkle = getPt(27), rAnkle = getPt(28);

            const shoulderWidth = Math.hypot(rShoulder.x - lShoulder.x, rShoulder.y - lShoulder.y);
            
            const theme = HERO_THEMES[0]; 
            const isClassic = theme.style === 'classic';

            const limbThickness = isClassic ? shoulderWidth * 0.35 : shoulderWidth * 0.25;

            canvasCtx.save();
            canvasCtx.lineCap = 'round';
            canvasCtx.lineJoin = 'round';

            const drawLimb = (start, end) => {
                canvasCtx.beginPath();
                canvasCtx.moveTo(start.x, start.y);
                canvasCtx.lineTo(end.x, end.y);
                canvasCtx.stroke();
            };

            if (isClassic) {
                // Classic White
                canvasCtx.strokeStyle = 'white';
                canvasCtx.lineWidth = limbThickness;
                
                drawLimb(lShoulder, lElbow);
                drawLimb(lElbow, lWrist);
                drawLimb(rShoulder, rElbow);
                drawLimb(rElbow, rWrist);
                
                drawLimb(lHip, lKnee);
                drawLimb(lKnee, lAnkle);
                drawLimb(rHip, rKnee);
                drawLimb(rKnee, rAnkle);

                canvasCtx.fillStyle = 'white';
                const centerX = (lShoulder.x + rShoulder.x) / 2;
                const centerY = (lShoulder.y + lHip.y) / 2;
                const torsoHeight = Math.abs(lHip.y - lShoulder.y);
                
                canvasCtx.beginPath();
                canvasCtx.ellipse(centerX, centerY, shoulderWidth * 0.8, torsoHeight * 0.7, 0, 0, 2 * Math.PI);
                canvasCtx.fill();
                
                canvasCtx.fillStyle = '#cbd5e1';
                canvasCtx.beginPath();
                canvasCtx.arc(centerX + shoulderWidth * 0.2, centerY - torsoHeight * 0.15, shoulderWidth * 0.1, 0, 2 * Math.PI);
                canvasCtx.fill();

            } else {
                // Armor
                canvasCtx.strokeStyle = theme.mainColor;
                canvasCtx.lineWidth = limbThickness * 0.8;
                
                drawLimb(lShoulder, lElbow);
                drawLimb(lElbow, lWrist);
                drawLimb(rShoulder, rElbow);
                drawLimb(rElbow, rWrist);
                
                drawLimb(lHip, lKnee);
                drawLimb(lKnee, lAnkle);
                drawLimb(rHip, rKnee);
                drawLimb(rKnee, rAnkle);

                canvasCtx.fillStyle = theme.mainColor;
                canvasCtx.beginPath();
                canvasCtx.moveTo(lShoulder.x, lShoulder.y);
                canvasCtx.lineTo(rShoulder.x, rShoulder.y);
                canvasCtx.lineTo(rHip.x, rHip.y);
                canvasCtx.lineTo(lHip.x, lHip.y);
                canvasCtx.fill();
                
                canvasCtx.fillStyle = 'white';
                canvasCtx.beginPath();
                canvasCtx.arc((lShoulder.x + rShoulder.x)/2, (lShoulder.y + rShoulder.y)/2 + shoulderWidth*0.2, shoulderWidth * 0.1, 0, 2 * Math.PI);
                canvasCtx.fill();
            }

            canvasCtx.restore();
        }

        // --- Face Mask Logic ---
        function drawHeroMask(landmarks, index) {
            const theme = HERO_THEMES[index % HERO_THEMES.length];
            const getPt = (idx) => ({ x: landmarks[idx].x * canvasElement.width, y: landmarks[idx].y * canvasElement.height });

            const faceOvalIndices = [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109];
            canvasCtx.beginPath();
            const startPt = getPt(faceOvalIndices[0]);
            canvasCtx.moveTo(startPt.x, startPt.y);
            for (let i = 1; i < faceOvalIndices.length; i++) canvasCtx.lineTo(getPt(faceOvalIndices[i]).x, getPt(faceOvalIndices[i]).y);
            canvasCtx.closePath();

            const noseTip = getPt(1);
            const chin = getPt(152);
            const forehead = getPt(10);
            const faceHeight = Math.sqrt(Math.pow(chin.x - forehead.x, 2) + Math.pow(chin.y - forehead.y, 2));

            const gradient = canvasCtx.createRadialGradient(noseTip.x, noseTip.y - faceHeight * 0.1, faceHeight * 0.1, noseTip.x, noseTip.y, faceHeight * 0.8);
            gradient.addColorStop(0, theme.highlight);
            gradient.addColorStop(0.4, theme.mainColor);
            gradient.addColorStop(1, theme.shadow);
            canvasCtx.fillStyle = gradient;
            // Removed cyberpunk glow
            canvasCtx.fill();
            
            canvasCtx.strokeStyle = "rgba(0,0,0,0.1)";
            canvasCtx.stroke();

            // Eyes
            const leftEyeCenter = { x: (getPt(33).x + getPt(133).x) / 2, y: (getPt(33).y + getPt(133).y) / 2 };
            const rightEyeCenter = { x: (getPt(362).x + getPt(263).x) / 2, y: (getPt(362).y + getPt(263).y) / 2 };
            const eyeDist = Math.sqrt(Math.pow(rightEyeCenter.x - leftEyeCenter.x, 2) + Math.pow(rightEyeCenter.y - leftEyeCenter.y, 2));
            const angle = Math.atan2(rightEyeCenter.y - leftEyeCenter.y, rightEyeCenter.x - leftEyeCenter.x);

            if (theme.style === 'visor') {
                const w = eyeDist * 2.5;
                const h = eyeDist * 0.9;
                const midX = (leftEyeCenter.x + rightEyeCenter.x) / 2;
                const midY = (leftEyeCenter.y + rightEyeCenter.y) / 2;
                canvasCtx.save();
                canvasCtx.translate(midX, midY);
                canvasCtx.rotate(angle);
                canvasCtx.fillStyle = theme.visorColor;
                drawRoundedRect(canvasCtx, -w/2, -h/2, w, h, h/2);
                canvasCtx.fill();
                canvasCtx.fillStyle = "rgba(255,255,255,0.2)";
                canvasCtx.beginPath();
                canvasCtx.ellipse(0, -h*0.25, w*0.35, h*0.15, 0, 0, Math.PI*2);
                canvasCtx.fill();
                canvasCtx.restore();
            }

            const r = eyeDist * 0.18;
            canvasCtx.fillStyle = theme.eyeColor;
            canvasCtx.strokeStyle = theme.eyeColor;
            canvasCtx.beginPath();
            canvasCtx.moveTo(leftEyeCenter.x, leftEyeCenter.y);
            canvasCtx.lineTo(rightEyeCenter.x, rightEyeCenter.y);
            canvasCtx.lineWidth = r * 0.6;
            canvasCtx.lineCap = 'round';
            canvasCtx.stroke();
            canvasCtx.beginPath();
            canvasCtx.arc(leftEyeCenter.x, leftEyeCenter.y, r, 0, 2*Math.PI);
            canvasCtx.arc(rightEyeCenter.x, rightEyeCenter.y, r, 0, 2*Math.PI);
            canvasCtx.fill();
        }

        // --- Hand Logic ---
        function checkHandGesture(handLandmarks) {
            if (isCountingDown) return;
            const wrist = handLandmarks[0];
            const fingers = [{tip: 8, base: 5}, {tip: 12, base: 9}, {tip: 16, base: 13}, {tip: 20, base: 17}];
            let fingersClosed = 0;
            fingers.forEach(f => {
                const dTip = Math.hypot(handLandmarks[f.tip].x - wrist.x, handLandmarks[f.tip].y - wrist.y);
                const dBase = Math.hypot(handLandmarks[f.base].x - wrist.x, handLandmarks[f.base].y - wrist.y);
                if (dTip < dBase) fingersClosed++;
            });

            if (fingersClosed >= 3) {
                fistDetectedFrames++;
                if (fistDetectedFrames > FIST_TRIGGER_FRAMES) startCountdown();
                else statusMsg.innerText = `Fist detected... Hold: ${((FIST_TRIGGER_FRAMES - fistDetectedFrames)/30).toFixed(1)}s`;
            } else {
                fistDetectedFrames = 0;
                if (!isCountingDown) statusMsg.innerText = "Show a ✊ (Fist) to take a screenshot!";
            }
        }

        function startCountdown() {
            if(isCountingDown) return;
            isCountingDown = true;
            let count = 3;
            countdownEl.style.display = 'block';
            countdownEl.innerText = count;
            statusMsg.innerText = "Hold steady!";

            const timer = setInterval(() => {
                count--;
                if (count > 0) countdownEl.innerText = count;
                else {
                    clearInterval(timer);
                    countdownEl.innerText = "";
                    takeScreenshot();
                }
            }, 1000);
        }

        function takeScreenshot() {
            flashOverlay.classList.remove('flash-active');
            void flashOverlay.offsetWidth;
            flashOverlay.classList.add('flash-active');
            const dataURL = canvasElement.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = `baymax-moment-${Date.now()}.png`;
            link.href = dataURL;
            link.click();
            isCountingDown = false;
            fistDetectedFrames = 0;
            statusMsg.innerText = "Screenshot saved! Show ✊ to take another.";
            countdownEl.style.display = 'none';
        }

        // --- Init Models ---
        const faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
        faceMesh.setOptions({ maxNumFaces: 4, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        faceMesh.onResults((res) => { isFaceLoaded = true; latestFaces = res; checkLoadStatus(); });

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults((res) => { isHandLoaded = true; latestHands = res; checkLoadStatus(); });

        const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
        pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        pose.onResults((res) => { isPoseLoaded = true; latestPose = res; checkLoadStatus(); });

        const camera = new Camera(videoElement, {
            onFrame: async () => {
                try {
                    await faceMesh.send({image: videoElement}); 
                    await hands.send({image: videoElement});
                    await pose.send({image: videoElement});
                } catch(e) { console.error("Tracking Error:", e); }
            },
            width: 1280,
            height: 720
        });

        requestAnimationFrame(renderLoop);
        camera.start().catch(e => { console.error("Camera Error:", e); alert("Please enable camera access."); });

    </script>
</body>
</html>